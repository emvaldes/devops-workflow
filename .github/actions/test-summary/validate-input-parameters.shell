#!/usr/bin/env bash

## File: .github/actions/test-summary/validate-input-parameters.shell
## Version: 0.0.1

set -x ;
set -e ;           # Exit on error
set -o pipefail ;  # Fail if any piped command fails

## validate-input-parameters.shell --json="{
##     "workflow": "pkgs.module-dependencies",
##     "params": {
##         "param": {
##             "key": "value"
##         }
##     }
## }" \
## --dry-run \
## --verbose \
## --debug ;

## validate-input-parameters.shell --json="{
##     "workflow": "pkgs.module-dependencies",
##     "params": {
##         "param": {
##             "key": {
##                 "id": "description"
##                 "event": "github.event.inputs.variable",
##                 "value": "inputs.variable"
##             }
##         }
##     }
## }" \
## --dry-run \
## --verbose \
## --debug ;

## This function expects the name of an associative array as its first argument.
function validate_input_parameters() {
    ## tracking_process ${FUNCNAME} "${@}";

    ## Handling JSON parameters (agnostic implementation)
    declare -a parameters=();
    local current="";
    local regex='^-{1,}[A-Za-z0-9_-]+(=.*)?$';
    for arg in "$@"; do
      if [[ "${arg}" =~ ${regex} ]]; then
              [[ -n "${current}" ]] && parameters+=( "${current}" );
              key="${arg%%=*}"; value="${arg#*=}";
              if [[ "${key}" != "${value}" ]]; then
                      if jq -e . <<< "${value}" &>/dev/null; then
                              value=$( jq -c . <<< "${value}" );
                        # else  echo -e "Invalid JSON:\n${value}";
                      fi;
                else  value='';
              fi;
              key="$( sed -e '1s|^\(-\)\{1,\}||' <<< "${arg%%=*}" )";
              current="${key}=${value}";
        else  current+=" ${arg}";
      fi;
    done; [[ -n "${current}" ]] && parameters+=( "${current}" );

    oIFS="${IFS}";
    for xitem in "${parameters[@]}"; do
      IFS='=' read -r key value <<< "$(
        echo -e "${xitem}" | sed -e '1s|^\(-\)\{1,\}||'
      )"; #echo -e "\nxitem: '${xitem}'\nkey: '${key}'\t->\tvalue: '${value}'";
      if [[ $key == "json" ]]; then
        local json_object="$(
          echo -e "${value}" \
          | sed 's/^[ \t]*//;s/[ \t]*$//' \
          | tr -d '\n\r' | jq -c .
        )";
      fi;
      #### ---------------------------------------------------------------------
      ## $key == "dry-run" ]] && local dry_run=true;
      [[ $key == "verbose" ]] && local verbose=true
      [[ $key == "debug" ]] && local debug=true
    done; IFS="${oIFS}";
    #### -----------------------------------------------------------------------
    ## [[ -z ${dry_run} ]] && local dry_run=false;
    [[ -z ${debug} ]] && local debug=false;
    [[ -z ${verbose} ]] && local verbose=false;
    #### -----------------------------------------------------------------------

    local warning_message="is missing or invalid!";
    # echo -e "Original JSON:\n${json_object}";

    ## Create a nameref to the associative array.
    if [[ -z "${json_object}" ]]; then
      [[ ${debug} == true ]] && \
        echo -e "Input Params: ${warning_message}";
      return 1;
    fi;

    ## Extract workflow name.
    local workflow_name;
    # workflow_name=$( echo "${json_object}" | jq -r '.workflow // empty' );
    workflow_name=$( echo "${json_object}" | jq --raw-output '.workflow' );
    if [[ -z "${workflow_name}" ]]; then
      [[ ${debug} == true ]] && \
        echo -e "Warning: Workflow ${warning_message}";
      exit 1;
    fi;

    ## Fix JSON structure: Ensure "event" always exists
    json_object=$(echo "${json_object}" | jq -c '
      .params |= with_entries(
        if .value | has("event") then .
        else .value.event = .value.value end
      )'
    )

    ## We'll get all parameter data into an array.
    local lines
    mapfile -t lines < <(
      echo "${json_object}" \
      | jq -r '.params | to_entries[] |
        "\(.key)\t\(.value.id)\t\(.value.event // "")\t\(.value.value // "")"'
    );

    # First pass: determine the maximum length of the left-hand side, i.e. "workflow[id]".
    local max_len=0;
    local line left len;
    for line in "${lines[@]}"; do
      IFS=$'\t' read -r id header event <<< "$line";
      left="${workflow_name}[${id}]";
      len=$( echo -n "$left" | wc -c );
      if (( len > max_len )); then max_len=$len; fi;
    done;

    # Directly iterate over parameters in "params" for validation.
    local invalid=false;

    declare -a warnings=();
    declare -a reporting=();
    declare -A report_json=();

    local error_header="cannot proceed without a valid";

    # Second pass: print each parameter using the calculated width.
    for line in "${lines[@]}"; do
      # echo -e "${line}";
      IFS=$'\t' read -r id title event value <<< "${line}";
      left="${workflow_name}[${id}]";
      # Use "event" if available; otherwise, use "value"
      if [[ -n "${event}" && "${event}" != "null" ]]; then
              param_value="${event}";
        else  param_value="${value}";
      fi;
      if [[ -z "$param_value" ]]; then
              warnings+=("$(
                printf "\nInvalid Input-Parameter:\n%s %s %s.\n" \
                       "${left}" "${error_header}" "${title}"
              )");
              invalid=true;
        else  # Use left-aligned field of width max_len
              reporting+=("$(
                printf "%-${max_len}s = %s\n" "${left}" "${param_value}";
              )");
              report_json["${id}"]="${param_value}";
      fi;
    done;

    ## Display if invalid parameters exist.
    if [[ ${invalid} == true ]]; then echo -e;
      for error in "${warnings[@]}"; do echo -e "${error}\n"; done;
      return 1;
    fi;

    ## Display only if --debug is requested
    if [[ ${debug} == true ]]; then echo -e;
      for valid in "${reporting[@]}"; do echo -e "${valid}"; done; echo -e;
    fi;

    first=true; json_output="{";
    for key in "${!report_json[@]}"; do
      [[ $first == false ]] && json_output+=",";
      ## **Trim spaces from param_value**
      value=$(
        echo "${report_json[$key]}" \
        | sed -E 's/^[[:space:]]+|[[:space:]]+$//g'
      )
      json_output+="\"$key\":\"${value}\"";
      first=false;
    done; json_output+="}";
    # echo -e "JSON Output: '${json_output}'"

    # Output transformed JSON
    jq . <<< "${json_output}";

    return 0;
  }; alias validate-parameters='validate_parameters';

validate_input_parameters "${@}";
