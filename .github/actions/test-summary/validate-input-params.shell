#!/usr/bin/env bash

## File: .github/actions/test-summary/validate-input-params.shell
## Version: 0.0.1

# set -x ;
set -e ;           # Exit on error
set -o pipefail ;  # Fail if any piped command fails

## validate_input_parameters \
##   --json="{
##       "workflow": "module.action-target",
##       "params": {
##           "title": "github.event.inputs.variable"
##       }
##   }" \
##   --dry-run \
##   --verbose ;

## This function expects the name of an associative array as its first argument.
function validate_input_parameters() {
    ## tracking_process ${FUNCNAME} "${@}";

    ## Combine all arguments into a single string by removing any extra whitespace
    local arguments;
    # arguments=$( echo -e "${@}" | tr -d '[[:blank:]]' | sed 's/  */ /g' );
    arguments=$( echo -e "$@" | sed 's/  */ /g' );

    oIFS="${IFS}";
    # for xitem in "${@}"; do
    for xitem in "${arguments}"; do
      IFS='='; set `echo -e "${xitem}" | sed -e '1s|^\(-\)\{1,\}||'`
      [[ ${1#*\--} = "json" ]] && local json_object="${2}";
      #### ---------------------------------------------------------------------
      ## [[ ${1#*\--} = "dry-run" ]] && local dry_run="${2}";
      [[ ${1#*\--} = "verbose" ]] && local verbose='true';
    done; IFS="${oIFS}";
    #### -----------------------------------------------------------------------
    ## [[ ${#dry_run} -eq 0 ]] && local dry_run='false';
    [[ ${#verbose} -eq 0 ]] && local verbose='false';
    #### -----------------------------------------------------------------------

    local warning_message="is missing or invalid!";

    ## Create a nameref to the associative array.
    if [[ -z "${json_object}" ]]; then
      echo -e "Input Params: ${warning_message}";
      return 1;
    fi;

    # echo -e "Original JSON:\n${json_object}";

    # Normalize JSON: remove newlines and extra spaces
    local compressed_json;
    compressed_json=$(
      echo "${json_object}" | tr -d '\n' | sed 's/  */ /g'
    )

    # Extract workflow name.
    local workflow_name;
    # workflow_name=$( echo "${compressed_json}" | jq -r '.workflow // empty' );
    workflow_name=$( echo "${compressed_json}" | jq --raw-output '.workflow' );
    if [[ -z "${workflow_name}" ]]; then
      echo -e "Warning: Workflow ${warning_message}";
      exit 1;
    fi;

    local invalid_params=false;
    local error_header="cannot proceed without a valid";

    echo -e "Compressed JSON (${workflow_name}):\n${compressed_json}\n";

    # We'll get all parameter data into an array.
    local lines
    mapfile -t lines < <(
      echo "${compressed_json}" \
      | jq -r '.params | to_entries[] | "\(.key)\t\(.value | to_entries[0].key)\t\(.value | to_entries[0].value)"'
    );

    # First pass: determine the maximum length of the left-hand side, i.e. "workflow[id]".
    local max_len=0;
    local line left len;
    for line in "${lines[@]}"; do
      IFS=$'\t' read -r id header value <<< "$line";
      left="${workflow_name}[${id}]";
      len=$( echo -n "$left" | wc -c );
      if (( len > max_len )); then max_len=$len; fi;
    done;

    # Directly iterate over parameters in "params" for validation.
    local invalid_params=false;
    # Iterate over parameters in "params" key/value pairs and extract them.
    #  - id (the internal key, e.g., "pytests_location")
    #  - header (the human-readable label, e.g., "PyTests Location")
    #  - value (the actual input value)

    # Second pass: print each parameter using the calculated width.
    for line in "${lines[@]}"; do
      IFS=$'\t' read -r id header value <<< "$line";
      left="${workflow_name}[${id}]";
      if [[ -z "$value" ]]; then
          printf "\nInvalid Input-Parameter:\n%s %s %s.\n" \
                 "$left" "$error_header" "$header";
          invalid_params=true;
      else
          # Use left-aligned field of width max_len
          printf "%-${max_len}s = %s\n" "$left" "$value";
      fi;
    done;

    if [[ ${invalid_params} == true ]]; then return 1; fi;
    echo -e;

    return 0;
  }; alias validate-parameters='validate_parameters';

validate_input_parameters ${@};
