#!/usr/bin/env bash

## File: .github/scripts/extract-pytest-functions.shell
## Version: 0.0.1

# set -x ;
set -e ;           # Exit on error
set -o pipefail ;  # Fail if any piped command fails

## extract-pytest-functions \
##   --pytests-location="tests/package/module" \
##   --output-filename="test_functions.json" \
##   --scripts-location=".github/scripts" \
##   --dry-run \
##   --verbose ;

function extract_pytest_functions () {
    ## tracking_process ${FUNCNAME} "${@}";

    script_dirname="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )";
    # read -ra parameters <<< "$( sanitize_parameters "${@}" )";
    # âœ… Capture output of sanitize_parameters as an array (preserving spaces)
    mapfile -t parameters < <( ${script_dirname}/sanitize-parameters.shell "${@}" );
    # echo -e; for param in "${parameters[@]}"; do echo -e "Parameter: '${param}'"; done;

    oIFS="${IFS}";
    for xitem in "${parameters[@]}"; do
      IFS='=' read -r key value <<< "$(
        echo -e "${xitem}" | sed -e '1s|^\(-\)\{1,\}||'
      )"; #echo -e "\nxitem: '${xitem}'\nkey: '${key}'\t->\tvalue: '${value}'";
      [[ $key == "pytests-location" ]] && local pytests_location="${value}";
      [[ $key = "output-filename" ]] && local output_filename="${value}";
      [[ $key = "scripts-location" ]] && local scripts_location="${value}";
      #### ---------------------------------------------------------------------
      ## $key == "dry-run" ]] && local dry_run=true;
      [[ $key == "verbose" ]] && local verbose=true
      [[ $key == "debug" ]] && local debug=true
    done; IFS="${oIFS}";
    #### -----------------------------------------------------------------------
    ## [[ -z ${dry_run} ]] && local dry_run=false;
    [[ -z ${debug} ]] && local debug=false;
    [[ -z ${verbose} ]] && local verbose=false;
    #### -----------------------------------------------------------------------

    ## Define custom-parameter(s):
    if [[ -z ${pytests_location} ]]; then
            echo -e "Error: PyTests Location is invalid or not provided!";
            exit 1;
            # Ensure the file exists before proceeding
      else  if [[ ! -e "${pytests_location}" ]]; then
              echo -e "Error: Target location was not found: ${pytests_location}";
              # echo -e '{"test_functions": ["dummy_test_function"]}' > "${output_filename}";
              exit 1;
            fi;
    fi;
    if [[ -z ${scripts_location} ]]; then
      scripts_location="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )";
    fi;
    if [[ -z ${pytests_location} ]]; then
      local output_filename="test_functions.json";
    fi;

    # pytests_location="tests/requirements/dependencies/test_dependencies.py" ;
    # echo -e "\nExtracting test functions from: ${pytests_location}\n";

    ## Find all test_*.py files recursively
    test_files=($(
      find "${pytests_location}" -type f -name "test_*.py"
    ));

    if [[ ${#test_files[@]} -eq 0 ]]; then
            echo -e "ERROR: No test files found in '${pytests_location}'!";
            # echo -e '{"test_functions": ["dummy_test_function"]}' > "${output_filename}";
            exit 1;
      # else  for file in ${test_files[@]}; do echo -e "Test File: ${file}"; done;
    fi;

    ## Convert Bash array to a properly formatted JSON array
    json_list=$( printf '%s\n' "${test_files[@]}" | jq -R . | jq -s . );
    # echo -e "PyTest files JSON:\n${json_list}\n";

    # echo -en "python3 ${scripts_location}/extract-pytest-functions.py ";
    # echo -e  ${json_list} ${output_filename};

    ## Call the external Python script instead of using here-doc
    python3 ${scripts_location}/extract-pytest-functions.py \
        "${json_list}" "${output_filename}";

    # ## Validate JSON before proceeding
    # jq -e . ${output_filename} 2>&1>/dev/null;
    # status=$?; #echo -e "Status: ${status}";
    # if [[ ${status} -gt 0 ]]; then
    #   echo -e "\nWarning: '${output_filename}' is not valid JSON object!";
    #   exit 1;
    # fi ;

    pytest_files="pytest_files.json";
    jq . ${output_filename} > ${pytest_files};
    # ls -al ${pytest_files};
    # jq -c . ${pytest>files};

    if [[ -e ${pytest_files} ]]; then
            jq -e . ${pytest_files} 2>&1>/dev/null ;
            status=$?; #echo -e "Status: ${status}" ;
            if [[ ${status} -gt 0 ]]; then
              echo -e "\Warning: '${pytest_files}' is not valid JSON object!";
              exit 1;
            fi;
      else  echo -e "Warning: ${pytest_files} is missing/not-found!";
            exit 1;
    fi;

    ## Flatten JSON: Extract functions into a single list
    # jq '[.test_functions | to_entries[] | .value[]]' \
    #    ${output_filename} > temp.json && mv temp.json ${output_filename};
    jq '{"test_functions": ( .test_functions | map(.[]) | flatten )}' \
       ${output_filename} > temp.json && mv temp.json ${output_filename};

    if [[ ! -e ${output_filename} ]]; then
      echo -e "Warning: ${output_filename} is missing/not-found!" ;
      exit 1;
    fi;

    # echo -e;
    return 0;
}; alias extract-pytest-functions='extract_pytest_functions';

extract_pytest_functions "${@}";
