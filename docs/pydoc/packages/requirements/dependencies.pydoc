### Documentation for /Users/emvaldes/.repos/devops/workflows/packages/requirements/dependencies.py

Help on module packages.requirements.dependencies in packages.requirements:

NAME
    packages.requirements.dependencies - File Path: packages/installer/install_requirements.py

DESCRIPTION
    Description:
        Dependency Management System
        This module handles the installation and verification of dependencies listed
        in a JSON requirements file. It supports both Pip and Brew (for macOS) package
        managers to ensure the correct versions of dependencies are installed and up-to-date.

    Core Features:
        - **Install Missing Dependencies**: Installs missing or outdated packages from a JSON file.
        - **Verify Installed Packages**: Checks installed versions of packages and ensures compliance with the requirements.
        - **Update Installed Packages**: Updates packages if necessary, ensuring all dependencies are correctly installed.
        - **Show Installed Packages**: Displays the installed versions of dependencies, highlighting any discrepancies.

    Usage:
        To install or update dependencies:
        ```python
        from install_requirements import install_requirements
        install_requirements(requirements_file="requirements.json", configs=configs)
        ```

        To show the installed packages:
        ```bash
        python install_requirements.py --show-installed
        ```

    Dependencies:
        - subprocess
        - argparse
        - json
        - importlib.metadata
        - pathlib
        - datetime
        - lib.system_variables (for project-wide configurations)
        - lib.pkgconfig_loader (for configuration handling)
        - lib.log_utils (for logging messages)
        - packages.appflow_tracer (for tracing setup)

    Global Variables:
        - `CONFIGS`: Stores the effective configurations used for logging and package installation.
        - `LIB_DIR`: Directory path for the `lib` directory.
        - `requirements_file`: Path to the JSON file containing the dependencies.

    Primary Functions:
        - `load_requirements(requirements_file, configs)`: Loads and parses the requirements JSON file.
        - `get_installed_version(package)`: Returns the installed version of a package, checking both Pip and Brew.
        - `install_requirements(requirements_file, configs)`: Installs or updates the required dependencies listed in the JSON file.
        - `install_or_update_package(package, version, configs)`: Installs or updates a specific package using Pip or Brew.
        - `is_brew_available()`: Checks if Brew (for macOS) is available on the system.
        - `is_package_installed(package, version_info, configs)`: Verifies whether a package is installed and meets the required version.
        - `parse_arguments()`: Parses the command-line arguments for specifying the requirements file and showing installed dependencies.
        - `print_installed_packages(config_filepath, configs)`: Prints the installed packages in a human-readable format.
        - `update_installed_packages(requirements_file, config_filepath, configs)`: Updates the status of installed packages and writes them to the installed JSON file.

    Expected Behavior:
        - Installs or updates packages listed in the JSON file to ensure they are up-to-date.
        - Verifies installed versions and logs appropriate messages.
        - Displays installed packages and their statuses when requested.
        - Logs the installation and verification process to assist with debugging.

    Exit Codes:
        - `0`: Successful execution.
        - `1`: Failure due to errors in installation, package not found, or missing configurations.

    Example:
        ```python
        from install_requirements import install_requirements
        install_requirements("requirements.json", configs)
        ```

FUNCTIONS
    get_installed_version(package: str) -> Optional[str]
        Return the installed version of a package, first checking Pip, then Brew.

        This function first checks if the package is installed via Pip, and if not,
        checks if it is available via Brew (macOS).

        Args:
            package (str): The name of the package to check.

        Returns:
            Optional[str]: The installed version of the package as a string if found, otherwise None.

    install_or_update_package(
        package: str,
        version: str = None,
        configs: dict = None
    ) -> None
        Install or update a package using Brew (if available) or Pip.

        This function attempts to install or update a package by first checking if Brew
        is available and then trying to install or upgrade using Pip if necessary.

        Args:
            package (str): The package name.
            version (str, optional): The required version of the package (default: None).
            configs (dict, optional): Configuration dictionary used for logging (default: None).

        Returns:
            None: This function installs or updates the package, but does not return any value.

    install_requirements(requirements_file: str, configs: dict) -> None
        Install missing dependencies from a JSON requirements file.

        This function iterates through the dependencies listed in the requirements file,
        checking if they are installed and installing missing or outdated packages.

        Args:
            requirements_file (str): The path to the JSON requirements file.
            configs (dict): Configuration dictionary used for logging.

        Returns:
            None: This function performs installations or updates but does not return any value.

    is_brew_available() -> bool
        Check if Homebrew is available on macOS.

        This function checks whether the system is running on macOS and if Homebrew is installed.

        Returns:
            bool: True if Brew is available on macOS, otherwise False.

    is_package_installed(package: str, version_info: dict, configs: dict) -> bool
        Check if a package is installed and meets the required version.

        This function checks if a package is installed, either via Pip or Brew (on macOS),
        and verifies that the installed version meets the specified version requirement.

        Args:
            package (str): The package name.
            version_info (dict): Dictionary containing version information.
            configs (dict): Configuration dictionary used for logging.

        Returns:
            bool: True if the package is installed and the version matches the requirement,
                  otherwise False.

    load_requirements(requirements_file: str, configs: dict) -> list
        Load the dependencies from a JSON requirements file.

        This function parses the JSON file, ensuring it contains the required dependencies
        and extracting the package names and their versions.

        Args:
            requirements_file (str): The path to the requirements JSON file.
            configs (dict): Configuration dictionary used for logging.

        Returns:
            list: A list of dictionaries containing package names and their respective versions.
                  Each dictionary contains the keys:
                    - 'package' (str): The package name.
                    - 'version' (dict): A dictionary with the package version.

        Raises:
            FileNotFoundError: If the requirements file does not exist.
            ValueError: If the JSON structure is invalid or the 'dependencies' key is missing.

    main() -> None
        Entry point for the package installer. Sets up logging, processes command-line arguments,
        and installs or updates dependencies from a JSON requirements file.

        Args:
            None

        Returns:
            None: This function serves as the main entry point, performing actions based on
                  the command-line arguments, such as installing or updating dependencies.

    parse_arguments() -> argparse.Namespace
        Parse command-line arguments for specifying the requirements file
        and displaying the installed dependencies.

        Args:
            None

        Returns:
            argparse.Namespace: The parsed arguments object containing selected options.

        Return Type: argparse.Namespace
            Returns an argparse.Namespace object containing the parsed command-line arguments.

    print_installed_packages(config_filepath: str, configs: dict) -> None
        Print the installed dependencies in a readable format.

        This function reads the installed packages from the specified file and logs
        their names, required versions, installed versions, and current status.

        Args:
            config_filepath (str): Path to the installed.json file.
            configs (dict): Configuration dictionary used for logging.

        Returns:
            None: This function prints the installed package details but does not return any value.

    update_installed_packages(
        requirements_file: str,
        config_filepath: str,
        configs: dict
    ) -> None
        Update the status of installed packages and write them to the installed JSON file.

        This function checks the installed versions of the packages listed in the requirements
        file and updates the status (installed, outdated, or newer) before writing the information
        to the installed.json file.

        Args:
            requirements_file (str): The path to the requirements JSON file.
            config_filepath (str): The path to the installed.json file.
            configs (dict): Configuration dictionary used for logging.

        Returns:
            None: This function updates the installed package statuses and writes the data
                  to the installed.json file, without returning any value.

DATA
    LIB_DIR = PosixPath('/Users/emvaldes/.repos/devops/workflows/lib')
    Optional = typing.Optional
        Optional[X] is equivalent to Union[X, None].

    Union = typing.Union
        Union type; Union[X, Y] means either X or Y.

        On Python 3.10 and higher, the | operator
        can also be used to denote unions;
        X | Y means the same thing to the type checker as Union[X, Y].

        To define a union, use e.g. Union[int, str]. Details:
        - The arguments must be types and there must be at least one.
        - None as an argument is a special case and is replaced by
          type(None).
        - Unions of unions are flattened, e.g.::

            assert Union[Union[int, str], float] == Union[int, str, float]

        - Unions of a single argument vanish, e.g.::

            assert Union[int] == int  # The constructor actually returns int

        - Redundant arguments are skipped, e.g.::

            assert Union[int, str, int] == Union[int, str]

        - When comparing unions, the argument order is ignored, e.g.::

            assert Union[int, str] == Union[str, int]

        - You cannot subclass or instantiate a union.
        - You can use Optional[X] as a shorthand for Union[X, None].

FILE
    /Users/emvaldes/.repos/devops/workflows/packages/requirements/dependencies.py



