### Documentation for /Users/emvaldes/.repos/devops/workflows/lib/pkgconfig_loader.py

Help on module lib.pkgconfig_loader in lib:

NAME
    lib.pkgconfig_loader - File Path: lib/pkgconfig_loader.py

DESCRIPTION
    Description:

    Package Configuration Loader

    This module provides a centralized mechanism for dynamically loading
    package-specific configurations. It ensures consistency across logging,
    tracing, and runtime parameters.

    Core Features:

    - **Dynamic Configuration Loading**: Reads settings from JSON config files.
    - **Logging Standardization**: Ensures uniform logging across all packages.
    - **Self-Inspection Mechanism**: Determines module-specific log file paths.
    - **Resilient JSON Parsing**: Handles corrupt or missing configuration files gracefully.

    Primary Functions:

    - `package_configs(overrides)`: Loads package configuration with optional overrides.
    - `setup_configs(absolute_path, logname_override)`: Initializes logging configuration for a module.

    Expected Behavior:

    - If a config file is missing, a default one is created.
    - JSON parsing errors trigger a warning and result in regeneration.
    - Logging configurations are structured for uniformity across modules.

    Dependencies:

    - `os`, `sys`, `json`, `pathlib`, `datetime`
    - `system_variables` (for directory paths and project settings)

    Usage:

    To load a package-specific configuration:
    > from lib.pkgconfig_loader import package_configs
    > config = package_configs()

    To set up logging for a module:
    > setup_configs("/path/to/module.py")

FUNCTIONS
    config_logfile(config: dict, caller_log_path: str = None) -> pathlib._local.Path
        Determine the correct log file path based on the caller module's request or self-inspection.

        This function generates a log file path based on the provided configuration. If a
        specific caller log path is provided, it resolves the path accordingly; otherwise,
        it defaults to the logging directory specified in the configuration.

        Args:
            config (dict): The configuration dictionary containing logging settings.
            caller_log_path (str, optional): A specific log directory path requested by the caller.

        Returns:
            Path: The resolved path for the log file.

    package_configs(overrides: dict = None) -> dict
        Load package configuration from a JSON file, or generate a default configuration if missing.

        This function attempts to load a package-specific configuration file. If the file is
        not found or is corrupted, a default configuration is generated, ensuring consistency
        across packages. The function supports overriding specific configuration keys.

        Args:
            overrides (dict, optional): A dictionary containing configuration values to override defaults.

        Raises:
            FileNotFoundError: If the JSON file is not found.
            json.JSONDecodeError: If the JSON file contains invalid syntax.

        Returns:
            dict: The loaded or generated package configuration.

    setup_configs(
        absolute_path: pathlib._local.Path,
        logname_override: str = None,
        events: Union[bool, list, dict, NoneType] = None
    ) -> dict
        Dynamically initialize and update logging configuration for the calling module.

        This function identifies the calling module, determines its package structure,
        and ensures logging configuration is properly set up, including log directory
        creation and configuration file management.

        Args:
            absolute_path (Path): The absolute path of the module requesting logging setup.
            logname_override (str, optional): A custom name for the log file, if needed.
            events (dict, optional): Events control settings.

        Raises:
            RuntimeError: If the function is called in an environment where the module path cannot be determined.
            OSError: If an error occurs while reading or writing the configuration file.

        Returns:
            dict: The updated logging configuration for the module.

DATA
    Optional = typing.Optional
        Optional[X] is equivalent to Union[X, None].

    Union = typing.Union
        Union type; Union[X, Y] means either X or Y.

        On Python 3.10 and higher, the | operator
        can also be used to denote unions;
        X | Y means the same thing to the type checker as Union[X, Y].

        To define a union, use e.g. Union[int, str]. Details:
        - The arguments must be types and there must be at least one.
        - None as an argument is a special case and is replaced by
          type(None).
        - Unions of unions are flattened, e.g.::

            assert Union[Union[int, str], float] == Union[int, str, float]

        - Unions of a single argument vanish, e.g.::

            assert Union[int] == int  # The constructor actually returns int

        - Redundant arguments are skipped, e.g.::

            assert Union[int, str, int] == Union[int, str]

        - When comparing unions, the argument order is ignored, e.g.::

            assert Union[int, str] == Union[str, int]

        - You cannot subclass or instantiate a union.
        - You can use Optional[X] as a shorthand for Union[X, None].

    category = namespace(calls=namespace(id='CALL', color='\x1b...'), rese...
    default_indent = 4
    max_logfiles = 5
    project_logs = PosixPath('/Users/emvaldes/.repos/devops/workflows/logs...
    project_packages = PosixPath('/Users/emvaldes/.repos/devops/workflows/...
    project_root = PosixPath('/Users/emvaldes/.repos/devops/workflows')
    timestamp = '20250302202516'

FILE
    /Users/emvaldes/.repos/devops/workflows/lib/pkgconfig_loader.py



